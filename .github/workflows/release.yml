name: Build

on:
  push:
    branches: [ main ]
    tags: [ "v*" ]
  pull_request:

jobs:
  native:
    name: native-${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up GraalVM (JDK 21)
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm-community'
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Align temp and Gradle dirs on D drive (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          echo "TMP=$env:RUNNER_TEMP"        >> $env:GITHUB_ENV
          echo "TEMP=$env:RUNNER_TEMP"       >> $env:GITHUB_ENV
          echo "GRADLE_USER_HOME=$env:RUNNER_TEMP\gradle" >> $env:GITHUB_ENV

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-read-only: ${{ github.ref != 'refs/heads/main' && !startsWith(github.ref, 'refs/tags/') }}

      # Generate metadata first, then compile (arm runner)
      - name: Generate Graal metadata (Linux/macOS)
        if: runner.os != 'Windows'
        env:
          DISABLE_DOCKER_TESTS: ${{ runner.os == 'macOS' && 'true' || 'false' }}
        run: ./gradlew --no-daemon -Dorg.gradle.jvmargs="-Xmx2g" -Pci=true -PtraceAgent=true clean test

      - name: Generate Graal metadata (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          DISABLE_DOCKER_TESTS: 'true'
        run: .\gradlew.bat --no-daemon "-Dorg.gradle.jvmargs=-Xmx2g" "-Djava.io.tmpdir=$env:RUNNER_TEMP" -Pci=true -PtraceAgent=true clean test

      - name: Upload test report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-report-${{ github.job }}-${{ runner.os }}-attempt${{ github.run_attempt }}
          path: build/reports/tests/test
          retention-days: 7

      - name: Build native image (Linux/macOS)
        if: runner.os != 'Windows'
        run: ./gradlew --no-daemon -Dorg.gradle.jvmargs="-Xmx2g" -Pci=true nativeCompile

      - name: Build native image (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: .\gradlew.bat --no-daemon "-Dorg.gradle.jvmargs=-Xmx2g" "-Djava.io.tmpdir=$env:RUNNER_TEMP" -Pci=true nativeCompile

      - name: Locate native binary path
        id: paths
        shell: bash
        run: |
          OUT_DIR="build/native/nativeCompile"
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            BIN="$(ls "$OUT_DIR"/*.exe)"
          else
            BIN="$(ls "$OUT_DIR"/* | head -n 1)"
          fi
          echo "bin=$BIN" >> $GITHUB_OUTPUT
          echo "out_dir=$OUT_DIR" >> $GITHUB_OUTPUT
          echo "Found: $BIN"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.event.repository.name }}-${{ matrix.os }}
          path: ${{ steps.paths.outputs.bin }}
          if-no-files-found: error
          retention-days: 14

  # NEW: native arm64 build on hosted ARM runner
  native-arm:
    name: native-ubuntu-24.04-arm
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up GraalVM (JDK 21)
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm-community'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Generate Graal metadata (arm64)
        run: ./gradlew --no-daemon -Dorg.gradle.jvmargs="-Xmx2g" -Pci=true -PtraceAgent=true clean test

      - name: Build native image (arm64)
        run: ./gradlew --no-daemon -Dorg.gradle.jvmargs="-Xmx2g" -Pci=true nativeCompile

      - name: Locate native binary path
        id: arm_paths
        shell: bash
        run: |
          OUT_DIR="build/native/nativeCompile"
          BIN="$(ls "$OUT_DIR"/* | head -n 1)"
          echo "bin=$BIN" >> $GITHUB_OUTPUT
          echo "Found: $BIN"

      - name: Upload arm64 artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.event.repository.name }}-ubuntu-24.04-arm
          path: ${{ steps.arm_paths.outputs.bin }}
          if-no-files-found: error
          retention-days: 14

  release:
    if: startsWith(github.ref, 'refs/tags/')
    needs: [ native, native-arm ]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Package versioned archives
        id: pkg
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${GITHUB_REF#refs/tags/}"
          files=()

          # macOS
          MAC_DIR=$(compgen -G 'dist/*macos*' || true)
          if [[ -n "${MAC_DIR:-}" ]]; then
            BIN=$(ls "$MAC_DIR"/* | head -n1)
            chmod +x "$BIN"
            TMPDIR="$(mktemp -d)"; mkdir -p "$TMPDIR/bin"; cp "$BIN" "$TMPDIR/bin/askimo"
            tar -C "$TMPDIR" -czf "askimo-${VERSION}-darwin-arm64.tar.gz" bin
            files+=("askimo-${VERSION}-darwin-arm64.tar.gz")
          fi

          # Linux amd64
          LIN_AMD_DIR=$(compgen -G 'dist/*ubuntu-latest*' || true)
          if [[ -n "${LIN_AMD_DIR:-}" ]]; then
            BIN=$(ls "$LIN_AMD_DIR"/* | head -n1)
            chmod +x "$BIN"
            TMPDIR="$(mktemp -d)"; mkdir -p "$TMPDIR/bin"; cp "$BIN" "$TMPDIR/bin/askimo"
            tar -C "$TMPDIR" -czf "askimo-${VERSION}-linux-x64.tar.gz" bin
            files+=("askimo-${VERSION}-linux-x64.tar.gz")
          fi

          # Linux arm64 (from native-arm)
          LIN_ARM_DIR=$(compgen -G 'dist/*ubuntu-24.04-arm*' || true)
          if [[ -n "${LIN_ARM_DIR:-}" ]]; then
            BIN=$(ls "$LIN_ARM_DIR"/* | head -n1)
            chmod +x "$BIN"
            TMPDIR="$(mktemp -d)"; mkdir -p "$TMPDIR/bin"; cp "$BIN" "$TMPDIR/bin/askimo"
            tar -C "$TMPDIR" -czf "askimo-${VERSION}-linux-arm64.tar.gz" bin
            files+=("askimo-${VERSION}-linux-arm64.tar.gz")
          fi

          # Windows
          WIN_DIR=$(compgen -G 'dist/*windows*' || true)
          if [[ -n "${WIN_DIR:-}" ]]; then
            EXE=$(ls "$WIN_DIR"/*.exe | head -n1)
            zip -j "askimo-${VERSION}-windows-x64.zip" "$EXE"
            files+=("askimo-${VERSION}-windows-x64.zip")
          fi

          if ((${#files[@]})); then
            shasum -a 256 "${files[@]}" > SHA256SUMS.txt
            files+=("SHA256SUMS.txt")
          fi

          {
            echo "files<<EOF"
            printf '%s\n' "${files[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.pkg.outputs.files }}
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref, '-rc') || contains(github.ref, '-beta') || contains(github.ref, '-alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  homebrew:
    name: Publish Homebrew tap (separate repo)
    if: startsWith(github.ref, 'refs/tags/')
    needs: [ release ]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Collect release assets & checksums
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          VERSION_PLAIN="${TAG#v}"
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          JSON="$(curl -sSL -H "Authorization: Bearer $GH_TOKEN" "$API")"
          ARM_NAME="askimo-${TAG}-darwin-arm64.tar.gz"
          AMD_NAME="askimo-${TAG}-darwin-amd64.tar.gz"
          BASE="https://github.com/${GITHUB_REPOSITORY}/releases/download/${TAG}"
          ARM_URL="$(echo "$JSON" | jq -r --arg N "$ARM_NAME" '.assets[] | select(.name==$N) | .browser_download_url')"
          AMD_URL="$(echo "$JSON" | jq -r --arg N "$AMD_NAME" '.assets[] | select(.name==$N) | .browser_download_url')"
          SHA_URL="$(echo "$JSON" | jq -r '.assets[] | select(.name=="SHA256SUMS.txt") | .browser_download_url')"
          if [ -z "$SHA_URL" ] || [ -z "$ARM_URL" ]; then
            echo "Release missing SHA256SUMS.txt or macOS arm64 tarball." >&2
            echo "$JSON" | jq -r '.assets[]?.name' >&2
            exit 1
          fi
          curl -sSL -o SHA256SUMS.txt "$SHA_URL"
          ARM_SHA="$(grep "  $ARM_NAME" SHA256SUMS.txt | awk '{print $1}')"
          AMD_SHA=""
          if [ -n "$AMD_URL" ]; then
            AMD_SHA="$(grep "  $AMD_NAME" SHA256SUMS.txt | awk '{print $1}')"
          fi
          echo "tag=$TAG"                     >> $GITHUB_OUTPUT
          echo "version_plain=$VERSION_PLAIN" >> $GITHUB_OUTPUT
          echo "arm_url=$ARM_URL"             >> $GITHUB_OUTPUT
          echo "arm_sha=$ARM_SHA"             >> $GITHUB_OUTPUT
          echo "amd_url=$AMD_URL"             >> $GITHUB_OUTPUT
          echo "amd_sha=$AMD_SHA"             >> $GITHUB_OUTPUT
      - name: Checkout tap repo
        uses: actions/checkout@v4
        with:
          repository: haiphucnguyen/homebrew-askimo
          token: ${{ secrets.TAP_PUSH_TOKEN }}
          path: tap
          fetch-depth: 0
      - name: Write formula into tap
        run: |
          set -euo pipefail
          mkdir -p tap/Formula
          cat > tap/Formula/askimo.rb <<'RUBY'
            class Askimo < Formula
            desc "AI-powered terminal assistant for multiple LLM providers"
            homepage "https://github.com/haiphucnguyen/askimo"
            version "VERSION_PLACEHOLDER"
            license "Apache-2.0"
          
            on_macos do
              on_arm do
                url "ARM_URL_PLACEHOLDER"
                sha256 "ARM_SHA_PLACEHOLDER"
              end
            end
          
            def install
              candidates = [
                "bin/askimo",
                "./bin/askimo",
                Dir["*/bin/askimo"].first,
                "askimo",
                Dir["*/askimo"].first
              ].compact
              path = candidates.find { |p| p && File.exist?(p) }
              odie "askimo binary not found; archive contained: #{Dir['**/*'][0,30].join(', ')}" unless path
              bin.install path => "askimo"
            end
          
            test do
              output = shell_output("#{bin}/askimo --version")
              assert_match "askimo", output.downcase
            end
          RUBY
          sed -i "s|VERSION_PLACEHOLDER|${{ steps.meta.outputs.version_plain }}|g" tap/Formula/askimo.rb
          sed -i "s|ARM_URL_PLACEHOLDER|${{ steps.meta.outputs.arm_url }}|g" tap/Formula/askimo.rb
          sed -i "s|ARM_SHA_PLACEHOLDER|${{ steps.meta.outputs.arm_sha }}|g" tap/Formula/askimo.rb
          echo "==== tap/Formula/askimo.rb ===="
          cat tap/Formula/askimo.rb
      - name: Commit & push to tap repo (single-commit history)
        working-directory: tap
        env:
          GIT_AUTHOR_NAME: github-actions
          GIT_AUTHOR_EMAIL: actions@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: actions@users.noreply.github.com
        run: |
          set -euo pipefail
          git rm -r --cached . >/dev/null 2>&1 || true
          git add Formula/askimo.rb
          git commit -m "askimo ${GITHUB_REF_NAME}" || echo "No changes"
          CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
          git push --force origin "$CURRENT_BRANCH"
  scoop:
    name: Publish Scoop manifest (Windows)
    if: startsWith(github.ref, 'refs/tags/')
    needs: [ release ]
    runs-on: ubuntu-latest
    permissions:
      contents: read   # reads current repo; pushes to bucket via PAT

    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Collect release assets & checksums
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"              # e.g. v0.1.013
          VERSION_PLAIN="${TAG#v}"
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          JSON="$(curl -sSL -H "Authorization: Bearer $GH_TOKEN" "$API")"

          WIN_NAME="askimo-${TAG}-windows-x64.zip"
          WIN_URL="$(echo "$JSON" | jq -r --arg N "$WIN_NAME" '.assets[] | select(.name==$N) | .browser_download_url')"
          SHA_URL="$(echo "$JSON" | jq -r '.assets[] | select(.name=="SHA256SUMS.txt") | .browser_download_url')"

          if [ -z "$WIN_URL" ] || [ -z "$SHA_URL" ]; then
            echo "Windows zip or SHA256SUMS.txt not found in the release." >&2
            echo "Assets:" >&2
            echo "$JSON" | jq -r '.assets[]?.name' >&2
            exit 1
          fi

          curl -sSL -o SHA256SUMS.txt "$SHA_URL"
          WIN_SHA="$(grep "  $WIN_NAME" SHA256SUMS.txt | awk '{print $1}')"
          if [ -z "$WIN_SHA" ]; then
            echo "SHA256 for $WIN_NAME not in SHA256SUMS.txt" >&2
            exit 1
          fi

          echo "version=$VERSION_PLAIN" >> $GITHUB_OUTPUT
          echo "win_url=$WIN_URL"       >> $GITHUB_OUTPUT
          echo "win_sha=$WIN_SHA"       >> $GITHUB_OUTPUT

      - name: Checkout scoop bucket
        uses: actions/checkout@v4
        with:
          repository: haiphucnguyen/scoop-askimo
          token: ${{ secrets.TAP_PUSH_TOKEN }}   # <-- use your existing PAT
          ref: main
          path: bucket
          fetch-depth: 0

      - name: Write askimo manifest
        run: |
          set -euo pipefail
          mkdir -p bucket/bucket
          printf '%s\n' \
            '{' \
            '  "version": "VERSION_PLACEHOLDER",' \
            '  "description": "AI-powered terminal assistant for multiple LLM providers",' \
            '  "homepage": "https://github.com/haiphucnguyen/askimo",' \
            '  "license": "Apache-2.0",' \
            '  "architecture": {' \
            '    "64bit": {' \
            '      "url": "WIN_URL_PLACEHOLDER",' \
            '      "hash": "WIN_SHA_PLACEHOLDER",' \
            '      "bin": "askimo.exe"' \
            '    }' \
            '  }' \
            '}' \
            > bucket/bucket/askimo.json
          sed -i "s|VERSION_PLACEHOLDER|${{ steps.meta.outputs.version }}|g" bucket/bucket/askimo.json
          sed -i "s|WIN_URL_PLACEHOLDER|${{ steps.meta.outputs.win_url }}|g" bucket/bucket/askimo.json
          sed -i "s|WIN_SHA_PLACEHOLDER|${{ steps.meta.outputs.win_sha }}|g" bucket/bucket/askimo.json
          cat bucket/bucket/askimo.json

      - name: Commit & push to bucket
        working-directory: bucket
        env:
          TOKEN: ${{ secrets.TAP_PUSH_TOKEN }}
        run: |
          set -euo pipefail
          # set identity LOCALLY (not global)
          git config user.name  "github-actions"
          git config user.email "actions@users.noreply.github.com"

          git add bucket/askimo.json
          if ! git diff --cached --quiet; then
            git commit -m "askimo ${GITHUB_REF_NAME}"
            # ensure remote uses PAT
            git remote set-url origin "https://x-access-token:${TOKEN}@github.com/haiphucnguyen/scoop-askimo.git"
            git push origin HEAD:main
          else
            echo "No changes to commit."
          fi

  docker:
    name: Build & Push Docker (native, multi-arch)
    if: startsWith(github.ref, 'refs/tags/')
    needs: [ release, native, native-arm ]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Download Linux amd64 artifact from the matrix 'native' job
      - name: Download amd64 artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ github.event.repository.name }}-ubuntu-latest
          path: dist-amd64

      - name: Normalize amd64 binary
        shell: bash
        run: |
          set -euo pipefail
          AMD="$(ls dist-amd64/* | head -n1)"
          chmod +x "$AMD"
          mkdir -p out
          cp "$AMD" out/askimo-amd64

      # Download Linux arm64 artifact from 'native-arm' job
      - name: Download arm64 artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ github.event.repository.name }}-ubuntu-24.04-arm
          path: dist-arm64

      - name: Normalize arm64 binary
        shell: bash
        run: |
          set -euo pipefail
          ARM="$(ls dist-arm64/* | head -n1)"
          chmod +x "$ARM"
          mkdir -p out
          cp "$ARM" out/askimo-arm64

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          REPO="ghcr.io/${GITHUB_REPOSITORY_OWNER}/askimo"
          V="${GITHUB_REF_NAME}"   # e.g. v1.2.3
          echo "base=$REPO"                                   >> $GITHUB_OUTPUT
          echo "tags=$REPO:latest,$REPO:${V},$REPO:${V#v}"    >> $GITHUB_OUTPUT

      # Build & push per-arch images (no QEMU; runtime-only copy)
      - name: Build amd64 image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.runtime
          build-args: BIN=out/askimo-amd64
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.base }}:amd64-temp
          provenance: false
          sbom: false

      - name: Build arm64 image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.runtime
          build-args: BIN=out/askimo-arm64
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.base }}:arm64-temp
          provenance: false
          sbom: false

      - name: Create & push multi-arch manifests
        shell: bash
        run: |
          set -euo pipefail
          I="${{ steps.meta.outputs.base }}"
          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.tags }}"
          for T in "${TAGS[@]}"; do
            docker manifest create "$T" \
              --amend "$I:amd64-temp" \
              --amend "$I:arm64-temp"
            docker manifest push "$T"
          done
          docker rmi "$I:amd64-temp" "$I:arm64-temp" || true
